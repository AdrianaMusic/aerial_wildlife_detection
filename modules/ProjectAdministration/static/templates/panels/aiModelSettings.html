<div>
    <h2>AI Model Settings</h2>

    <p style="font-weight:bold;color:red">Work in progress, not stable yet.</p>

    <div class="settings-group">
        <input type="checkbox" id="ai-model-enabled-checkbox" />
        <label for="ai-model-enabled-checkbox">AI model enabled</label><br />
    </div>
    
    <div class="settings-group">
        <label for="ai-model-class">Prediction model</label><br />
        <select id="ai-model-class">
            <option value="unset">Choose:</option>
        </select>
        <p id="ai-model-class-descr"></p>
    </div>

    <div class="settings-group">
        <label for="al-model-class">Ranking model</label><br />
        <select id="al-model-class">
            <option value="unset">Choose:</option>
        </select>
        <p id="al-model-class-descr"></p>
    </div>

    <div id="seg-unlabeled-box" class="settings-group" style="display:none">
        <label for="seg-unlabeled-select">Treat unlabeled areas in image as:</label>
        <select id="seg-unlabeled-select">
            <option value="1">unlabeled (ignore)</option>
            <option value="0">background</option>
        </select>
        <p id="seg-unlabeled-info-text" style="font-style:italic;font-size:10pt;margin-left:20px;"></p>
    </div>

    <div>
        <button id="save-button" class="btn btn-primary" style="float:right">Save</button>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function() {

        // AI model metadata
        var aiModelSelect = $('#ai-model-class');
        var alModelSelect = $('#al-model-class');

        //TODO: flag for case when AIController is not available...
        var promise = $.ajax({
                url: 'getProjectImmutables',
                method: 'GET',
                success: function(data) {
                    data = data['immutables'];
                    window.annotationType = data['annotationType'];
                    window.predictionType = data['predictionType'];
                },
                error: function(data) {
                    console.error(data);
                }
        });
        promise = promise.then(function() {
            return $.ajax({
                url: '/getAvailableAImodels',
                method: 'GET',
                success: function(data) {
                    // populate selection fields, if suitable for selected annotation and prediction types
                    window.availableModels = data['models'];
                    for(var key in data['models']['prediction']) {
                        var annoTypes = data['models']['prediction'][key]['annotationType'];
                        var predTypes = data['models']['prediction'][key]['predictionType'];
                        if(!Array.isArray(annoTypes)) annoTypes = [annoTypes];
                        if(!Array.isArray(predTypes)) predTypes = [predTypes];
                        if(annoTypes.includes(window.annotationType) && predTypes.includes(window.predictionType)) {
                            var entry = $('<option value="' + key + '">' + data['models']['prediction'][key]['name'] + '</option>');
                            aiModelSelect.append(entry);
                        }
                    }
                    for(var key in data['models']['ranking']) {
                        var entry = $('<option value="' + key + '">' + data['models']['ranking'][key]['name'] + '</option>');
                        alModelSelect.append(entry);
                    }
                },
                error: function(data) {
                    //TODO
                    console.log('ERROR:')
                    console.log(data)
                }
            });
        });

        function loadSettings() {
            return $.ajax({
                url: 'getConfig',
                method: 'POST',
                data: JSON.stringify({
                    'parameters': [
                        'ai_model_enabled',
                        'ai_model_library',
                        'ai_model_settings',
                        'ai_alcriterion_library',
                        'ai_alcriterion_settings',
                        'numimages_autotrain',
                        'minnumannoperimage',
                        'maxnumimages_train',
                        'segmentation_ignore_unlabeled'
                    ]
                }),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json',
                success: function(data) {
                    data = data['settings'];

                    // checkbox
                    $('#ai-model-enabled-checkbox').prop('checked', data['ai_model_enabled']);

                    // set selected AI and AL models
                    let aiLib = data['ai_model_library'];
                    let rankerLib = data['ai_alcriterion_library'];
                    if(aiLib === null || aiLib === undefined || !(window.availableModels['prediction'].hasOwnProperty(aiLib))) {
                        aiModelSelect.val('unset');
                        $('#ai-model-class-descr').html('');
                    } else {
                        aiModelSelect.val(data['ai_model_library']);
                        $('#ai-model-class-descr').html(window.availableModels['prediction'][data['ai_model_library']]['description']);
                    }
                    if(rankerLib === null || rankerLib === undefined ||Â !(window.availableModels['ranking'].hasOwnProperty(rankerLib))) {
                        alModelSelect.val('unset');
                        $('#al-model-class-descr').html('');
                    } else {
                        alModelSelect.val(data['ai_alcriterion_library']);
                        $('#al-model-class-descr').html(window.availableModels['ranking'][data['ai_alcriterion_library']]['description']);
                    }

                    // for segmentation masks only: how to treat unlabeled areas
                    if(window.annotationType === 'segmentationMasks') {
                        let selectedOption = (data['segmentation_ignore_unlabeled'] ? '1' : '0');
                        $('#seg-unlabeled-select').val(selectedOption);
                        $('#seg-unlabeled-select').trigger('change');
                        $('#seg-unlabeled-box').show();
                    }
                }
            });
        }

        promise = promise.then(function() {
            return loadSettings();
        });

        // show model descriptions upon change
        aiModelSelect.change(function() {
            var selModel = $(this).val();
            if(selModel === 'unset') {
                $('#ai-model-class-descr').html('');
            } else {
                $('#ai-model-class-descr').html(window.availableModels['prediction'][selModel]['description']);
            }
        });
        alModelSelect.change(function() {
            var selModel = $(this).val();
            if(selModel === 'unset') {
                $('#al-model-class-descr').html('');
            } else {
                $('#al-model-class-descr').html(window.availableModels['ranking'][selModel]['description']);
            }
        });

        $('#ai-model-enabled-checkbox').change(function() {
            aiModelSelect.prop('disabled', !$(this).prop('checked'));
            alModelSelect.prop('disabled', !$(this).prop('checked'));
        });

        $('#seg-unlabeled-select').change(function() {
            let infoDiv = $('#seg-unlabeled-info-text');
            if($(this).val() === '1') {
                infoDiv.html('Any pixels that are not painted by annotators will be ignored during model training. Note that this will result in models always predicting a label for every pixel.');
            } else {
                infoDiv.html('Any pixels that are not painted by annotators will be treated as "background." To this end, a new hidden "background" class with index (value) zero will be added to the project (if not existing).');
            }
        });

        $('#save-button').click(function() {
            window.showLoadingOverlay(true);

            // assemble config parameters and submit
            let modelLib = (aiModelSelect.val() === 'unset'? null : aiModelSelect.val());
            let rankerLib = (alModelSelect.val() === 'unset'? null : alModelSelect.val());
            var settings = {
                'ai_model_enabled': $('#ai-model-enabled-checkbox').prop('checked'),
                'ai_model_library': modelLib,
                'ai_alcriterion_library': rankerLib,
                'ai_alcriterion_library': alModelSelect.val()
            };
            if(window.annotationType === 'segmentationMasks') {
                settings['segmentation_ignore_unlabeled'] = ($('#seg-unlabeled-select').val() === '1');
            }
            var p = $.ajax({
                url: 'saveAImodelSettings',
                method: 'POST',
                contentType: 'application/json; charset=utf-8',
                dataType: 'json',
                data: JSON.stringify({'settings': settings}),
                success: function(data) {
                    console.log(data['status']);
                    if(data.hasOwnProperty('message')) {
                        console.log(data['message']);
                    }
                },
                error: function(data) {
                    console.error(data);
                }
            });
            p = p.then(function() {
                return loadSettings();
            });
            p.then(function() {
                window.showLoadingOverlay(false);
            });
        });

        promise.then(function() {
            window.showLoadingOverlay(false);
        });
    });
</script>