<div>
    <h2>Model states</h2>

    <div class="tables-container">
        <table>
            <thead>
                <tr>
                    <th><input type="checkbox" id="select-all-states" /></th>
                    <th>#</th>
                    <th>Time created</th>
                    <th>Model</th>
                    <th>Ranking model</th>
                    <th>No. predictions</th>
                </tr>
            </thead>
            <tbody id="cnn-states-tbody"></tbody>
        </table>
        <div style="margin-top:10px">
            <button class="btn btn-sm btn-primary" id="reload-button" style="margin-right:10px">Reload</button>
            <button class="btn btn-sm btn-danger" id="delete-selected-models-button">Delete selected</button>
        </div>
    </div>

    <h2 style="margin-top:20px">Training statistics</h2>
    <div id="training-statistics-container"></div>
</div>
<link rel="stylesheet" href="/static/statistics/libs/chartjs/Chart.min.css?v={{ version }}" />
<style>
    table {
        width: 100%;
        height: 90%;
        max-height: 90%;
        border: 1px solid #aaa;
    }

    thead {
        background: #5f5f5f;
        font-weight: bold;
    }

    tbody {
        overflow-x: hidden;
        overflow-y: auto;
        max-height: 200px;
    }

    thead, tbody {
        display: block;
        padding-left: 5px;
        padding-right: 5px;
    }

    td, th {
        padding-right: 5px;
    }

    .header-toggle {
        cursor: pointer;
    }
</style>
<script src="/static/dataAdmin/js/taskPolling.js?v={{ version }}"></script>
<script src="/static/statistics/libs/chartjs/Chart.min.js?v={{ version }}"></script>
<script type="text/javascript">

    let COLORS = ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928'];

    function getSelectedModelIDs() {
        let modelStates = [];
        $('#cnn-states-tbody').find('input[type=checkbox]:checked').each(function() {
            modelStates.push($(this).attr('id'));
        });
        return modelStates
    }

    function getAvailableAImodels() {
        return $.ajax({
            url: window.baseURL + 'getAvailableAImodels',
            method: 'GET',
            success: function(data) {
                availableAImodels = data['models']['prediction'];
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to load installed AI model types (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return getAvailableAImodels();
                    });
                }
            }
        });
    }

    function listModelStates() {
        let modelStateTable = $('#cnn-states-tbody');
        modelStateTable.empty();
        return $.ajax({
            url: window.baseURL + 'listModelStates',
            method: 'GET',
            success: function(data) {
                if(data.hasOwnProperty('modelStates')) {
                    data = data['modelStates'];
                    for(var i=0; i<data.length; i++) {
                        // construct model state markup
                        var markup = $('<tr></tr>');
                        markup.append($('<td><input type="checkbox" id="'+data[i]['id']+'" /></td>'));
                        markup.append($('<td>' + (data.length-i) + '</td>'));
                        markup.append($('<td>'+new Date(data[i]['time_created'] * 1000).toLocaleString()+'</td>'));
                        markup.append($('<td>'+data[i]['model_library']['name']+'</td>'));
                        markup.append($('<td>'+data[i]['al_criterion_library']['name']+'</td>'));
                        markup.append($('<td>'+data[i]['num_pred']+'</td>'));
                        modelStateTable.append(markup);
                    }

                    // select all checkbox
                    $('#select-all-states').off();
                    $('#select-all-states').click(function() {
                        var checked = $(this).prop('checked');
                        $.each($('#cnn-states-tbody').find('input[type=checkbox]'), function() {
                            $(this).prop('checked', checked);
                        });
                    });
                }
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to retrieve AI model states (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return listModelStates();
                    });
                }
            }
        });
    }


    function getTrainingStats() {
        let containerDiv = $('#training-statistics-container');
        containerDiv.empty();
        let _poll_stats = function(data) {
            if(typeof(data) === 'object' && data.hasOwnProperty('series')) {
                // assemble line charts for each model library
                let modelLibs = Object.keys(data['series']);

                for(var m=0; m<modelLibs.length; m++) {
                    let modelLib = modelLibs[m];
                    let timestamps = [];
                    for(var t=0; t<data['timestamps'][modelLib].length; t++) {
                        let timestamp = data['timestamps'][modelLib][t] * 1000;
                        timestamps.push(new Date(timestamp));
                    }
                    let seriesNames = Object.keys(data['series'][modelLib]);
                    let datasets = [];
                    for(var s=0; s<seriesNames.length; s++) {
                        let seriesName = seriesNames[s];
                        datasets.push({
                            label: seriesName,
                            data: data['series'][modelLib][seriesName],
                            borderColor: COLORS[(COLORS.length-1) % (s+1)],
                            fill: false
                        });
                    }

                    // create chart
                    let modelName = window.availableAImodels[modelLib]['name'];
                    let header = $('<h3 class="header-toggle">'+modelName+'</h3>');
                    containerDiv.append(header);
                    let canvas = $('<canvas height=300></canvas>');
                    containerDiv.append(canvas);
                    header.on('click', function() {
                        canvas.slideToggle();
                    });
                    new Chart(canvas[0].getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: timestamps,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                xAxes: [{
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            'millisecond': 'MMM DD YYYY, hh:mm:ss',
                                            'second': 'MMM DD YYYY, hh:mm:ss',
                                            'minute': 'MMM DD YYYY, hh:mm:ss',
                                            'hour': 'MMM DD YYYY, hh:mm:ss',
                                            'day': 'MMM DD YYYY, hh:mm:ss',
                                            'week': 'MMM DD YYYY, hh:mm:ss',
                                            'month': 'MMM DD YYYY, hh:mm:ss',
                                            'quarter': 'MMM DD YYYY, hh:mm:ss',
                                            'year': 'MMM DD YYYY, hh:mm:ss'
                                        }
                                    }
                                }]
                            }
                        }
                    });
                }
            }
        }

        return $.ajax({
            url: window.baseURL + 'getModelTrainingStatistics',
            method: 'GET',
            success: function(data) {
                let taskID = data['task_id'];
                if(typeof(taskID) === 'string') {
                    poll_status(taskID, function(data) {
                        _poll_stats(data);
                    },
                    function(data) {
                        _poll_stats(data);
                    }, 1000);
                }
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to load training statistics (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return doShareModel();
                    });
                }
            }
        })
    }

    function deleteSelectedModels() {
        let selModels = getSelectedModelIDs();
        if(selModels.length === 0) return;

        let _on_message = function(numModels, data) {
            if(data.hasOwnProperty('status') && data['status'] === 'FAILURE') {
                // error
                let message = '(an unknown error occurred)';
                if(data.hasOwnProperty('meta') && data['meta'].hasOwnProperty('message')) {
                    message = 'an error occurred trying to delete model states (' + data['meta']['message'] + ').';
                }
                window.messager.addMessage(message, 'error', 0);
            } else {
                let promise = listModelStates()
                promise = promise.then(function() {
                    return getTrainingStats();
                });
                promise.then(function() {
                    window.messager.addMessage('Successfully deleted ' + numModels + ' model states.', 'success');
                });
            }
        }

        let _do_delete = function() {
            return $.ajax({
                url: window.baseURL + 'deleteModelStates',
                method: 'POST',
                data: JSON.stringify({model_ids: selModels}),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json',
                success: function(data) {
                    let taskID = data['task_id'];
                    if(typeof(taskID) === 'string') {
                        poll_status(taskID, function(data) {
                            _on_message(selModels.length, data);
                        },
                        function(data) {
                            _on_message(selModels.length, data);
                        }, 1000);
                    } else {
                        if(data.hasOwnProperty('message')) {
                            window.messager.addMessage('An error occurred while trying to delete model states (message: "'+data['message']+'").', 'error', 0);
                        } else {
                            window.messager.addMessage('An unknown error occurred while trying to delete model states', 'error', 0);
                        }
                    }
                },
                error: function(xhr, status, error) {
                    window.messager.addMessage('An error occurred while deleting model states (message: "'+error+'").', 'error', 0);
                },
                statusCode: {
                    401: function(xhr) {
                        return window.renewSessionRequest(xhr, function() {
                            return _do_delete();
                        });
                    }
                }
            });
        }

        window.showYesNoOverlay($('<div>Are you sure you would like to delete ' + selModels.length + ' model states?<br />This also removes predictions made by those models. The action cannot be undone.</div>'),
            _do_delete, null, 'Delete', 'Cancel', 'btn-danger', 'btn-secondary', false, false);
    }

    function reloadAll(showMessage) {
        let promise = listModelStates();
        promise = promise.then(function() {
            return getTrainingStats();
        });
        if(showMessage) {
            return promise.then(function() {
                window.messager.addMessage('Successfully reloaded model states and performance statistics.', 'success');
                return $.Deferred().resolve().promise();
            });
        }
        return promise;
    }


    $(document).ready(function() {
        //TODO: show summary, running processes, etc.
        window.save = undefined;

        let promise = $.when(getAvailableAImodels(), listModelStates());

        promise = promise.then(function() {
            return getTrainingStats();
        });

        promise.then(function() {
            $('#reload-button').on('click', function() {
                return reloadAll(true);
            });
            $('#delete-selected-models-button').on('click', function() {
                return deleteSelectedModels(); 
            });

            window.showLoadingOverlay(false);
        });
    });
</script>