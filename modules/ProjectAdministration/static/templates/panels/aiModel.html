<div>
    <h2>Model states</h2>

    <div class="tables-container">
        <table>
            <thead>
                <tr>
                    <th><input type="checkbox" id="select-all-states" /></th>
                    <th>#</th>
                    <th>Time created</th>
                    <th>Model</th>
                    <th>Ranking model</th>
                    <th>No. predictions</th>
                </tr>
            </thead>
            <tbody id="cnn-states-tbody"></tbody>
        </table>
        <div style="margin-top:10px">
            <button class="btn btn-sm btn-primary" id="reload-button" style="margin-right:10px">Reload</button>
            <button class="btn btn-sm btn-danger" id="delete-selected-models-button">Delete selected</button>
        </div>
    </div>

    <h2 style="margin-top:20px">Training statistics</h2>
    <div id="loading-placeholder">loading...</div>
    <div id="training-statistics-container"></div>
    <div id="no-data-placeholder" style="display:none">
        <div>no data to show</div>
    </div>
</div>
<link rel="stylesheet" href="/static/statistics/libs/chartjs/Chart.min.css?v={{ version }}" />
<style>
    table {
        width: 100%;
        height: 90%;
        max-height: 90%;
        border: 1px solid #aaa;
    }

    thead {
        background: #5f5f5f;
        font-weight: bold;
    }

    tbody {
        overflow-x: hidden;
        overflow-y: auto;
        max-height: 200px;
    }

    thead, tbody {
        display: block;
        padding-left: 5px;
        padding-right: 5px;
    }

    td, th {
        padding-right: 5px;
    }

    .header-toggle {
        cursor: pointer;
    }
</style>
<script src="/static/dataAdmin/js/taskPolling.js?v={{ version }}"></script>
<script src="/static/statistics/libs/chartjs/Chart.min.js?v={{ version }}"></script>
<script type="text/javascript">

    let COLORS = ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928'];

    function getSelectedModelIDs() {
        let modelStates = [];
        $('#cnn-states-tbody').find('input[type=checkbox]:checked').each(function() {
            modelStates.push($(this).attr('id'));
        });
        return modelStates
    }

    function getAvailableAImodels() {
        return $.ajax({
            url: window.baseURL + 'getAvailableAImodels',
            method: 'GET',
            success: function(data) {
                availableAImodels = data['models']['prediction'];
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to load installed AI model types (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return getAvailableAImodels();
                    });
                }
            }
        });
    }

    function listModelStates() {
        let modelStateTable = $('#cnn-states-tbody');
        modelStateTable.empty();
        return $.ajax({
            url: window.baseURL + 'listModelStates',
            method: 'GET',
            success: function(data) {
                if(data.hasOwnProperty('modelStates')) {
                    data = data['modelStates'];
                    for(var i=0; i<data.length; i++) {
                        // construct model state markup
                        var markup = $('<tr></tr>');
                        markup.append($('<td><input type="checkbox" id="'+data[i]['id']+'" /></td>'));
                        markup.append($('<td>' + (data.length-i) + '</td>'));
                        markup.append($('<td>'+new Date(data[i]['time_created'] * 1000).toLocaleString()+'</td>'));
                        markup.append($('<td>'+data[i]['model_library']['name']+'</td>'));
                        markup.append($('<td>'+data[i]['al_criterion_library']['name']+'</td>'));
                        markup.append($('<td>'+data[i]['num_pred']+'</td>'));
                        modelStateTable.append(markup);
                    }

                    // select all checkbox
                    $('#select-all-states').off();
                    $('#select-all-states').click(function() {
                        var checked = $(this).prop('checked');
                        $.each($('#cnn-states-tbody').find('input[type=checkbox]'), function() {
                            $(this).prop('checked', checked);
                        });
                    });
                }
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to retrieve AI model states (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return listModelStates();
                    });
                }
            }
        });
    }


    function getTrainingStats(showMessageOnSuccess) {
        let containerDiv = $('#training-statistics-container');
        containerDiv.empty();
        $('#loading-placeholder').show();
        $('#no-data-placeholder').hide();
        let _poll_stats = function(data, success) {
            if(typeof(data) !== 'object') {
                data = {};
                success = false;
            }
            if(success) {
                let hasChart = false;
                if(data.hasOwnProperty('series')) {
                    // assemble line charts for each model library
                    let modelLibs = Object.keys(data['series']);
                    for(var m=0; m<modelLibs.length; m++) {
                        let modelLib = modelLibs[m];
                        let timestamps = [];
                        for(var t=0; t<data['timestamps'][modelLib].length; t++) {
                            let timestamp = data['timestamps'][modelLib][t] * 1000;
                            timestamps.push(new Date(timestamp));
                        }
                        let seriesNames = Object.keys(data['series'][modelLib]);
                        let datasets = [];
                        for(var s=0; s<seriesNames.length; s++) {
                            let seriesName = seriesNames[s];
                            datasets.push({
                                label: seriesName,
                                data: data['series'][modelLib][seriesName],
                                borderColor: COLORS[(COLORS.length-1) % (s+1)],
                                fill: false
                            });
                        }

                        // create chart
                        let modelName = window.availableAImodels[modelLib]['name'];
                        let header = $('<h3 class="header-toggle">'+modelName+'</h3>');
                        containerDiv.append(header);
                        let canvas = $('<canvas height=300></canvas>');
                        containerDiv.append(canvas);
                        header.on('click', function() {
                            canvas.slideToggle();
                        });
                        new Chart(canvas[0].getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: timestamps,
                                datasets: datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    xAxes: [{
                                        type: 'time',
                                        time: {
                                            displayFormats: {
                                                'millisecond': 'MMM DD YYYY, hh:mm:ss',
                                                'second': 'MMM DD YYYY, hh:mm:ss',
                                                'minute': 'MMM DD YYYY, hh:mm:ss',
                                                'hour': 'MMM DD YYYY, hh:mm:ss',
                                                'day': 'MMM DD YYYY, hh:mm:ss',
                                                'week': 'MMM DD YYYY, hh:mm:ss',
                                                'month': 'MMM DD YYYY, hh:mm:ss',
                                                'quarter': 'MMM DD YYYY, hh:mm:ss',
                                                'year': 'MMM DD YYYY, hh:mm:ss'
                                            }
                                        }
                                    }]
                                }
                            }
                        });
                        hasChart = true;
                    }
                }
                $('#loading-placeholder').hide();
                if(!hasChart) {
                    $('#no-data-placeholder').show();
                }
                if(showMessageOnSuccess) {
                    window.messager.addMessage('Successfully loaded model training statistics.', 'success');
                }
            } else {
                // failure
                $('#loading-placeholder').hide();
                $('#no-data-placeholder').hide();
                let message = 'An unknown error occurred trying to load model training statistics.';
                if(typeof(data['message']) === 'string' && data['message'].length > 0) {
                    message = 'An error occurred trying to load model training statistics (message: "' + data['message'] + '").';
                }
                window.messager.addMessage(mesage, 'error', 0);
            }
        }

        return $.ajax({
            url: window.baseURL + 'getModelTrainingStatistics',
            method: 'GET',
            success: function(data) {
                let taskID = data['task_id'];
                if(typeof(taskID) === 'string') {
                    poll_status(taskID, function(data) {
                        _poll_stats(data, true);
                    },
                    function(data) {
                        _poll_stats(data, false);
                    }, 1000);
                }
            },
            error: function(xhr, status, error) {
                console.error(error);
                if(typeof(xhr) === 'object' && xhr.hasOwnProperty('status') && xhr['status'] !== 401) {
                    window.messager.addMessage('An error occurred while trying to load training statistics (message: "' + error + '").', 'error', 0);
                }
            },
            statusCode: {
                401: function(xhr) {
                    return window.renewSessionRequest(xhr, function() {
                        return doShareModel();
                    });
                }
            }
        })
    }

    function deleteSelectedModels() {
        let selModels = getSelectedModelIDs();
        if(selModels.length === 0) return;

        let _on_message = function(numModels, data) {
            if(data.hasOwnProperty('status') && data['status'] === 'FAILURE') {
                // error
                let message = '(an unknown error occurred)';
                if(data.hasOwnProperty('meta') && data['meta'].hasOwnProperty('message')) {
                    message = 'an error occurred trying to delete model states (' + data['meta']['message'] + ').';
                }
                window.messager.addMessage(message, 'error', 0);
            } else {
                let promise = listModelStates()
                promise = promise.then(function() {
                    return getTrainingStats(false);
                });
                promise.then(function() {
                    window.messager.addMessage('Successfully deleted ' + numModels + ' model states.', 'success');
                });
            }
        }

        let _do_delete = function() {
            return $.ajax({
                url: window.baseURL + 'deleteModelStates',
                method: 'POST',
                data: JSON.stringify({model_ids: selModels}),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json',
                success: function(data) {
                    let taskID = data['task_id'];
                    if(typeof(taskID) === 'string') {
                        poll_status(taskID, function(data) {
                            _on_message(selModels.length, data);
                        },
                        function(data) {
                            _on_message(selModels.length, data);
                        }, 1000);
                    } else {
                        if(data.hasOwnProperty('message')) {
                            window.messager.addMessage('An error occurred while trying to delete model states (message: "'+data['message']+'").', 'error', 0);
                        } else {
                            window.messager.addMessage('An unknown error occurred while trying to delete model states', 'error', 0);
                        }
                    }
                },
                error: function(xhr, status, error) {
                    window.messager.addMessage('An error occurred while deleting model states (message: "'+error+'").', 'error', 0);
                },
                statusCode: {
                    401: function(xhr) {
                        return window.renewSessionRequest(xhr, function() {
                            return _do_delete();
                        });
                    }
                }
            });
        }

        window.showYesNoOverlay($('<div>Are you sure you would like to delete ' + selModels.length + ' model states?<br />This also removes predictions made by those models. The action cannot be undone.</div>'),
            _do_delete, null, 'Delete', 'Cancel', 'btn-danger', 'btn-secondary', false, false);
    }

    function reloadAll(showMessageOnSuccess) {
        let promise = listModelStates();
        promise = promise.then(function() {
            return getTrainingStats(showMessageOnSuccess);
        });
        return promise;
    }


    $(document).ready(function() {
        //TODO: show summary, running processes, etc.
        window.save = undefined;

        let promise = $.when(getAvailableAImodels(), listModelStates());

        promise = promise.then(function() {
            return getTrainingStats(false);
        });

        promise.then(function() {
            $('#reload-button').on('click', function() {
                return reloadAll(true);
            });
            $('#delete-selected-models-button').on('click', function() {
                return deleteSelectedModels(); 
            });

            window.showLoadingOverlay(false);
        });
    });
</script>